//
// Prefix header for all source files of the 'Ads' target in the 'Ads' project
//

#ifdef __OBJC__
    #import <Foundation/Foundation.h>
    #import "HZEnums.h"
    #import "HZNotifications.h"
    #import "HZAdInfo.h"

// When NSAssert prints its callstack to the console, its not symbolicated. I'm not sure why. It would be good to know, and ideally have a solution that doesn't involve developers changing anything.
// This version is copied exactly from NSAssert, but additionally prints the callstack.

#define HZAssert(condition, desc, ...)	\
do {				\
__PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS \
if (!(condition)) {		\
NSLog(@"Callstack = %@",[NSThread callStackSymbols]); \
[[NSAssertionHandler currentHandler] handleFailureInMethod:_cmd \
object:self file:[NSString stringWithUTF8String:__FILE__] \
lineNumber:__LINE__ description:(desc), ##__VA_ARGS__]; \
}				\
__PRAGMA_POP_NO_EXTRA_ARG_WARNINGS \
} while(0)

#define HZParameterAssert(condition) HZAssert((condition), @"Invalid parameter not satisfying: %s", #condition)

// Use `HZFail` instead of HZ(Parameter)Assert if you always want to trigger the assertion.
// Using `HZFail` is preferable over something like HZAssert(NO,@"msg") because code flow analysis won't think that the method will potentially finish without returning a value.

#define HZFail(desc, ...)	\
do {				\
__PRAGMA_PUSH_NO_EXTRA_ARG_WARNINGS \
NSLog(@"Callstack = %@",[NSThread callStackSymbols]); \
NSString *const assertionMessage = [NSString stringWithFormat:(@"Assertion failure in method: %@ file: %s line: %i reason: " desc) ,NSStringFromSelector(_cmd), __FILE__, __LINE__, ##__VA_ARGS__]; \
@throw [NSException exceptionWithName:NSInternalInconsistencyException reason:assertionMessage userInfo:nil]; \
__PRAGMA_POP_NO_EXTRA_ARG_WARNINGS \
} while(0)

#endif

